<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <title>Panel Aiken</title>

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #eef2f5;
      padding: 20px;
    }

    .container {
      background: #fff;
      max-width: 1100px;
      margin: auto;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 12px rgba(0, 0, 0, .1);
    }

    h2,
    h3 {
      text-align: center;
    }

    .panel {
      text-align: center;
      margin-bottom: 20px;
    }

    .panel button {
      background: #004aad;
      margin: 6px;
    }

    .panel button:hover {
      background: #0066ff;
    }

    .section {
      border: 1px solid #ccc;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 6px;
    }

    textarea {
      width: 100%;
      height: 180px;
      margin-top: 10px;
    }

    button {
      margin: 6px;
      padding: 10px 18px;
      background: rgb(0, 101, 0);
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 5px;
    }

    button:hover {
      background: rgb(0, 207, 0);
    }

    .reset {
      background: rgb(255, 89, 89);
    }

    .reset:hover {
      background: rgb(255, 0, 0);
    }

    .stats {
      font-weight: bold;
      margin-top: 8px;
    }

    .modulo {
      display: none;
    }
  </style>
</head>

<body>

  <div class="container">
    <h2>ğŸ“š Panel Aiken Unificado</h2>

    <!-- PANEL -->
    <div class="panel">
      <button onclick="mostrar('pf')">ğŸ“˜ Parcial / Final</button>
      <button onclick="mostrar('comp')">ğŸ” Comparador</button>
      <button onclick="mostrar('multi')">ğŸ“‚ Multi-Archivos</button>
    </div>
    <!-- ================= PARCIAL / FINAL ================= -->
    <div id="pf" class="modulo">

      <h3>ğŸ“˜ Parcial / Final</h3>

      <div class="section">
        <h3>ğŸ“˜ Examen Parcial</h3>
        <input type="file" id="pf_parcial" accept=".txt">
        <br>
        <button onclick="pfProcesar('parcial')">âš™ Procesar Parcial</button>
        <button onclick="descargarTexto(pf_data.parcial,'EP.txt')">â¬‡ Descargar Parcial</button>

        <textarea id="pf_out_parcial"></textarea>
        <div class="stats" id="pf_stats_parcial"></div>

        <h4>ğŸ§© Duplicados Parcial</h4>
        <textarea id="dup_pf_parcial" readonly></textarea>
        <p id="cnt_pf_parcial"></p>

      </div>

      <div class="section">
        <h3>ğŸ“• Examen Final</h3>
        <input type="file" id="pf_final" accept=".txt">
        <br>
        <button onclick="pfProcesar('final')">âš™ Procesar Final</button>
        <button onclick="descargarTexto(pf_data.final,'EF.txt')">â¬‡ Descargar Final</button>

        <textarea id="pf_out_final"></textarea>
        <div class="stats" id="pf_stats_final"></div>

        <h4>ğŸ§© Duplicados Final</h4>
        <textarea id="dup_pf_final" readonly></textarea>
        <p id="cnt_pf_final"></p>

      </div>

      <div class="section">
        <button onclick="pfUnir()">ğŸ”¥ Unir y Depurar</button>
        <button onclick="descargarTexto(pf_data.union,'RECUPERACIÃ“N.txt')">â¬‡ Descargar UniÃ³n</button>

        <textarea id="pf_out_union"></textarea>
        <div class="stats" id="pf_stats_union"></div>

        <h4>ğŸ§© Duplicados UniÃ³n</h4>
        <textarea id="dup_pf_union" readonly></textarea>
        <p id="cnt_pf_union"></p>

      </div>

      <button class="reset" onclick="pfLimpiar()">ğŸ§¹ Limpiar</button>
    </div>


    <!-- ================= COMPARADOR ================= -->
    <div id="comp" class="modulo">

      <h3>ğŸ” Comparador Aiken</h3>

      <div class="section">
        <h3>ğŸ“˜ Archivo Principal (Referencia)</h3>
        <input type="file" id="c_principal">
        <textarea id="c_txt_principal"></textarea>
      </div>

      <div class="section">
        <h3>ğŸ“„ Archivo a Comparar</h3>
        <input type="file" id="c_comparar">
        <textarea id="c_txt_comparar"></textarea>
      </div>

      <div class="section">
        <button onclick="comparar()">ğŸ” Comparar</button>
        <button onclick="descargarTexto(comp_resultado,'no_encontradas.txt')">â¬‡ Descargar Resultado</button>
        <textarea id="c_resultado"></textarea>
        <div class="stats" id="c_stats"></div>
      </div>

      <button class="reset" onclick="compLimpiar()">Limpiar</button>
    </div>

    <!-- ================= MULTI ARCHIVOS ================= -->
    <div id="multi" class="modulo">

      <h3>ğŸ“‚ Multi-Archivos</h3>

      <div class="section">
        <h4>ğŸ“¥ Arrastra aquÃ­ los archivos TXT</h4>
        <div id="dropZone" style="border:2px dashed #666;padding:30px;text-align:center;
           background:#f9f9f9;border-radius:8px;cursor:pointer;">
          Arrastra uno o varios archivos .txt aquÃ­<br>
          o haz clic para seleccionar
        </div>
        <input type="file" id="m_files" multiple accept=".txt" style="display:none">
        <p id="m_info"></p>
      </div>

      <div class="section">
        <button onclick="procesarMulti()">âš™ Procesar</button>
        <button onclick="descargarTexto(m_resultado,'aiken_unificado.txt')">â¬‡ Descargar Resultado</button>
        <textarea id="m_out"></textarea>
        <div class="stats" id="m_stats"></div>

        <h4>ğŸ§© Duplicados Multi</h4>
        <textarea id="dup_multi" readonly></textarea>
        <p id="cnt_multi"></p>

      </div>

      <button class="reset" onclick="multiLimpiar()">Limpiar</button>
    </div>

  </div>

  <script>
    /* ===== UTILIDADES COMUNES ===== */
    function mostrar(id) {
      document.querySelectorAll('.modulo').forEach(m => m.style.display = 'none');
      document.getElementById(id).style.display = 'block';
    }

    function limpiarFormatoAiken(texto) {
      return texto
        .replace(/\t+/g, " ")          // TAB â†’ espacio
        .replace(/([A-Z])\.\s+/g, "$1. ") // A.   â†’ A.
        .replace(/\s+$/gm, "");        // espacios al final de lÃ­nea
    }

    function repararOpcionesEnLinea(bloque) {
      const lineas = bloque.split("\n");
      const salida = [];

      lineas.forEach(l => {
        // Solo dividir si hay varias alternativas reales en una lÃ­nea
        if (/(^|\s)(A\.|B\.|C\.|D\.|E\.)\s+.+(\s+(B\.|C\.|D\.|E\.)\s+)/.test(l)) {
          const partes = l.split(/(?=(?:^|\s)[A-E]\.\s+)/g);
          partes.forEach(p => salida.push(p.trim()));
        } else {
          salida.push(l);
        }
      });

      return salida.join("\n");
    }


    function separarAnswer(bloque) {
      return bloque.replace(/\s*(ANSWER:\s*[A-Z])/, "\n$1");
    }

    function normalizar(t) {
      return t.toLowerCase().normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[Â¿?Â¡!.,:;]/g, "")
        .replace(/\s+/g, "");
    }

    function limpiarEspaciosLinea(texto) {
      return texto
        .replace(/\u00A0/g, " ")
        .replace(/\t+/g, " ")
        .replace(/ {2,}/g, " ")
        .replace(/\s+([.,;:])/g, "$1")
        .replace(/\n\s+/g, "\n")
        .replace(/\s+\n/g, "\n")
        .replace(/^([A-E]\.)\s+/gm, "$1 ")
        .trim();
    }

    function procesarTexto(texto) {
      texto = limpiarEspaciosLinea(texto);
      const bloques = parsearAikenSeguro(texto);

      const mapa = new Map();
      const resultado = [];
      const duplicados = [];

      bloques.forEach(bloque => {
        const lineas = bloque.split("\n");

        const clave =
          normalizar(lineas[0]) +
          lineas
            .filter(l => /^[A-E]\./.test(l))
            .map(normalizar)
            .join("");

        if (!mapa.has(clave)) {
          mapa.set(clave, bloque);
          resultado.push(bloque);
        } else {
          duplicados.push({
            original: mapa.get(clave),
            repetido: bloque
          });
        }
      });

      return {
        textoFinal: resultado.join("\n\n"),
        duplicados,
        total: resultado.length + duplicados.length,
        unicos: resultado.length,
        repetidos: duplicados.length
      };
    }

    function descargarTexto(txt, nombre) {
      if (!txt) return alert("No hay contenido");
      const b = new Blob([txt], { type: "text/plain" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(b);
      a.download = nombre; a.click();
    }

    function mostrarDuplicados(duplicados, areaId, contadorId) {
      const area = document.getElementById(areaId);
      const contador = document.getElementById(contadorId);

      if (!area || !contador) return;

      if (duplicados.length === 0) {
        area.value = "âœ… No se detectaron preguntas duplicadas.";
        contador.textContent = "";
        return;
      }

      let salida = "";

      duplicados.forEach((d, i) => {
        salida += `ğŸ”¹ DUPLICADO #${i + 1}\n`;
        salida += `ğŸ“Œ Conservada:\n${d.original}\n\n`;
        salida += `âŒ Eliminada:\n${d.repetido}\n`;
        salida += "\n-----------------------------\n\n";
      });

      area.value = salida;
      contador.textContent =
        `âš ï¸ Total de duplicados eliminados: ${duplicados.length}`;
    }


    /* ===== PARCIAL FINAL ===== */
    const pf_data = { parcial: "", final: "", union: "" };

    function pfProcesar(tipo) {
      const f = document.getElementById("pf_" + tipo).files[0];
      if (!f) return alert("Seleccione archivo");
      leer(f, t => {
        const r = procesarTexto(t);
        pf_data[tipo] = r.textoFinal;
        document.getElementById("pf_out_" + tipo).value = r.textoFinal;
        document.getElementById("pf_stats_" + tipo).innerText =
          `Originales: ${r.total} | Ãšnicas: ${r.unicos} | Duplicadas: ${r.repetidos}`;
        mostrarDuplicados(
          r.duplicados,
          "dup_pf_" + tipo,
          "cnt_pf_" + tipo
        );
      });
    }

    function pfUnir() {
      const r = procesarTexto(pf_data.parcial + "\n\n" + pf_data.final);
      pf_data.union = r.textoFinal;
      pf_out_union.value = r.textoFinal;
      pf_stats_union.innerText =
        `Originales: ${r.total} | Ãšnicas: ${r.unicos} | Duplicadas: ${r.repetidos}`;
      mostrarDuplicados(
        r.duplicados,
        "dup_pf_union",
        "cnt_pf_union"
      );
    }

    function pfLimpiar() {
      // limpiar datos
      pf_data.parcial = "";
      pf_data.final = "";
      pf_data.union = "";

      // limpiar inputs file
      document.getElementById("pf_parcial").value = "";
      document.getElementById("pf_final").value = "";

      // limpiar textareas
      document.querySelectorAll("#pf textarea").forEach(t => t.value = "");

      // limpiar contadores
      document.querySelectorAll("#pf .stats").forEach(s => s.innerText = "");

      // limpiar contadores de duplicados
      document.getElementById("cnt_pf_parcial").innerText = "";
      document.getElementById("cnt_pf_final").innerText = "";
      document.getElementById("cnt_pf_union").innerText = "";
    }

    /* ===== COMPARADOR ===== */
    let comp_resultado = "";
    let comp_principal_txt = "";
    let comp_comparar_txt = "";

    document.getElementById("c_principal").addEventListener("change", e => {
      const f = e.target.files[0];
      if (!f) return;
      leer(f, t => {
        comp_principal_txt = t;
        c_txt_principal.value = t;
      });
    });

    document.getElementById("c_comparar").addEventListener("change", e => {
      const f = e.target.files[0];
      if (!f) return;
      leer(f, t => {
        comp_comparar_txt = t;
        c_txt_comparar.value = t;
      });
    });

    function comparar() {
      if (!comp_principal_txt || !comp_comparar_txt)
        return alert("Cargue ambos archivos");

      const ref = new Set();

      parsearAikenSeguro(comp_principal_txt).forEach(b => {
        const clave = generarClave(b);
        ref.add(clave);
      });

      const noEncontradas = [];

      parsearAikenSeguro(comp_comparar_txt).forEach(b => {
        const clave = generarClave(b);
        if (!ref.has(clave)) {
          noEncontradas.push(b);
        }
      });

      comp_resultado = noEncontradas.join("\n\n");
      c_resultado.value = comp_resultado;
      c_stats.innerText = `No encontradas: ${noEncontradas.length}`;
    }

    function generarClave(bloque) {
      const lineas = bloque.split("\n");
      return normalizar(lineas[0]) +
        lineas.filter(l => /^[A-E]\./.test(l)).map(normalizar).join("");
    }


    function compLimpiar() {
      comp_resultado = "";
      comp_principal_txt = "";
      comp_comparar_txt = "";

      // inputs
      document.getElementById("c_principal").value = "";
      document.getElementById("c_comparar").value = "";

      // textareas
      document.querySelectorAll("#comp textarea").forEach(t => t.value = "");

      // contador
      document.getElementById("c_stats").innerText = "";
    }

    /* ===== MULTI ===== */
    let m_resultado = "";

    function genInputs() {
      const n = m_cantidad.value;
      m_inputs.innerHTML = "";
      for (let i = 1; i <= n; i++) {
        const f = document.createElement("input");
        f.type = "file"; f.accept = ".txt"; m_inputs.appendChild(f);

      }
    }

    async function procesarMulti() {
      if (multiFiles.length === 0)
        return alert("Arrastra al menos un archivo");

      let txt = "";
      for (const f of multiFiles) {
        txt += await leerP(f) + "\n\n";
      }

      const r = procesarTexto(txt);
      m_resultado = r.textoFinal;
      m_out.value = r.textoFinal;
      m_stats.innerText =
       m_stats.innerText =
  `Originales: ${r.total} | Ãšnicas: ${r.unicos} | Duplicadas: ${r.repetidos}`;


      mostrarDuplicados(r.duplicados, "dup_multi", "cnt_multi");
    }


    function multiLimpiar() {
      m_resultado = "";
      multiFiles = [];
      m_out.value = "";
      m_stats.innerText = "";
      m_info.innerText = "";
      dup_multi.value = "";
      cnt_multi.innerText = "";
      fileInput.value = "";
    }


    function leer(f, cb) {
      const r = new FileReader();
      r.onload = e => cb(e.target.result);
      r.readAsText(f, "UTF-8");
    }

    function leerP(f) {
      return new Promise(res => leer(f, res));
    }

    /* ===== MULTI DRAG & DROP ===== */
    const dropZone = document.getElementById("dropZone");
    const fileInput = document.getElementById("m_files");
    let multiFiles = [];

    dropZone.addEventListener("click", () => fileInput.click());

    fileInput.addEventListener("change", e => {
      multiFiles = [...e.target.files];
      actualizarInfoMulti();
    });

    dropZone.addEventListener("dragover", e => {
      e.preventDefault();
      dropZone.style.background = "#e0f0ff";
    });

    dropZone.addEventListener("dragleave", () => {
      dropZone.style.background = "#f9f9f9";
    });

    dropZone.addEventListener("drop", e => {
      e.preventDefault();
      dropZone.style.background = "#f9f9f9";
      multiFiles = [...e.dataTransfer.files].filter(f => f.name.endsWith(".txt"));
      actualizarInfoMulti();
    });

    function actualizarInfoMulti() {
      m_info.innerText =
        multiFiles.length === 0
          ? "No hay archivos cargados"
          : `ğŸ“‚ Archivos cargados: ${multiFiles.length}`;
    }

    mostrar('pf');

    function parsearAikenSeguro(texto) {
      const lineas = texto
        .replace(/\t+/g, " ")
        .split("\n")
        .map(l => l.trim())
        .filter(l => l.length > 0);

      const bloques = [];
      let i = 0;

      while (i < lineas.length) {
        // â›” NO saltar preguntas aunque el formato sea imperfecto
        let pregunta = lineas[i];
        i++;
        const opciones = [];
        // Leer hasta 5 alternativas mÃ¡ximo
        while (i < lineas.length && /^[A-E]\.\s*/.test(lineas[i]) && opciones.length < 5) {
          opciones.push(lineas[i]);
          i++;
        }
        let answer = "";
        if (i < lineas.length && /^ANSWER:\s*[A-E]$/i.test(lineas[i])) {
          answer = lineas[i];
          i++;
        }
        // ğŸ§  SIEMPRE conservar la pregunta
        const bloque = [
          pregunta,
          ...opciones,
          answer
        ].filter(Boolean).join("\n");
        bloques.push(bloque);
      }
      return bloques;
    }

  </script>

</body>

</html>
